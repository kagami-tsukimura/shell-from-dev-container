#!/usr/bin/env python3

# ./pyminish
import os
import signal
import sys


def builtin_echo(args):
    print("".join(args))


def builtin_exit(args):
    exit(0)


def builtin_clear(args):
    # 033: 8é€²æ•°ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹
    print("\033[H\033[2J\033[3J", end="")


BUILTIN_COMMAND_FUNC_MAPPING = {
    "echo": builtin_echo,
    "exit": builtin_exit,
    "clear": builtin_clear,
}


def find_command(command):
    if "/" in command:
        return command if os.path.exists(command) else None

    for path_dir in os.environ["PATH"].split(":"):
        full_path = os.path.join(path_dir, command)
        if os.path.exists(full_path) and not os.path.isdir(full_path):
            return full_path
    return None


def set_stdio(stdin_fd=None, stdout_fd=None):
    # dup2: ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã§ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’å¤‰æ›´
    if stdin_fd is not None:
        # sys.stdin.fileno(): 0
        os.dup2(stdin_fd, sys.stdin.fileno())
    if stdout_fd is not None:
        # sys.stdout.fileno(): 1
        os.dup2(stdout_fd, sys.stdout.fileno())


def run_command(tokens, stdin_fd=None, stdout_fd=None):
    command = tokens[0]
    args = tokens[1:]

    # TODO: run command
    if command in BUILTIN_COMMAND_FUNC_MAPPING:
        default_stdin = os.dup(sys.stdin.fileno())
        default_stdout = os.dup(sys.stdin.fileno())
        # ä¸€æ™‚çš„ã«æ¨™æº–å‡ºåŠ›ã‚’ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã«åˆ‡ã‚Šæ›¿ãˆã‚‹
        set_stdio(stdin_fd, stdout_fd)
        # å†…éƒ¨ã‚³ãƒãƒ³ãƒ‰
        BUILTIN_COMMAND_FUNC_MAPPING[command](args)
        # ã‚·ã‚§ãƒ«ã®æ¨™æº–å‡ºåŠ›ã‚’å¤‰æ›´ã—ã¦ã—ã¾ã„ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¡¨ç¤ºã‚‚å‡ºã¦ã—ã¾ã†ãŸã‚ã€æ¨™æº–å…¥å‡ºåŠ›ã‚’æˆ»ã™
        set_stdio(default_stdin, default_stdout)
    else:
        # å¤–éƒ¨ã‚³ãƒãƒ³ãƒ‰
        command_path = find_command(command)
        if command_path is None:
            print(f"Command not found: {command}", file=sys.stderr)
            return

        # ã‚·ã‚§ãƒ«ã®å®Ÿè¡Œ
        # NOTE: ãƒ—ãƒ­ã‚»ã‚¹ã‚’è¤‡è£½ã—ã¦è¦ªãƒ—ãƒ­ã‚»ã‚¹ã¨å­ãƒ—ãƒ­ã‚»ã‚¹ã«åˆ†ã‘ã‚‹
        pid = os.fork()

        if pid == 0:
            # æ¨™æº–å‡ºåŠ›ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’å¤‰æ›´
            set_stdio(stdin_fd, stdout_fd)
            # ãƒ‘ã‚¹ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–ã‚Šå‡ºã™
            command_basename = os.path.basename(command_path)
            # NOTE: ãƒ—ãƒ­ã‚»ã‚¹ã«é–¢ã™ã‚‹å‡¦ç†ã‚’ã‚«ãƒ¼ãƒãƒ«ã«ä¾é ¼ï¼ˆåˆ¥ãƒ—ãƒ­ã‚»ã‚¹èµ·å‹•ï¼‰
            os.execve(command_path, [command_basename] + args, os.environ)
        else:
            os.waitpid(pid, 0)
            return


def interpret_line(line):
    if line.strip().startswith("#"):
        return

    tokens = line.split()

    if len(tokens) == 0:
        return

    redirection_count = tokens.count(">")
    pipe_count = tokens.count("|")

    if redirection_count + pipe_count >= 2:
        print("More than 2 redirections or pipes are not supported", file=sys.stderr)
        return

    if redirection_count == 1:
        # ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆæ™‚ã®å‡¦ç†
        redirection_index = tokens.index(">")
        # ">" ä»¥å‰ã‚’ã‚³ãƒãƒ³ãƒ‰ã¨å¼•æ•°ã¨ã—ã¦å–ã‚Šå‡ºã™
        command_and_args = tokens[:redirection_index]
        # ">" ã®å³å´ã‚’ãƒ•ã‚¡ã‚¤ãƒ«åã¨ã—ã¦å–ã‚Šå‡ºã™
        stdout_file_name = tokens[redirection_index + 1]

        with open(stdout_file_name, "w") as f:
            # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ç¢ºèªã—ã¦å®Ÿè¡Œ
            stdout_fd = f.fileno()
            run_command(command_and_args, stdout_fd=stdout_fd)

        pass
    elif pipe_count == 1:
        # ãƒ‘ã‚¤ãƒ—æ™‚ã®å‡¦ç†
        pipe_index = tokens.index("|")
        # "|" ä»¥å‰ã‚’ã‚³ãƒãƒ³ãƒ‰ã¨å¼•æ•°ã¨ã—ã¦å–ã‚Šå‡ºã™
        command_and_args1 = tokens[:pipe_index]
        pipe_index += 1
        command_and_args2 = tokens[pipe_index:]

        pipe_r, pipe_w = os.pipe()

        run_command(command_and_args1, stdout_fd=pipe_w)
        os.close(pipe_w)
        run_command(command_and_args2, stdin_fd=pipe_r)
        os.close(pipe_r)
    else:
        run_command(tokens)


def sigint_handler(signum, frame):
    pass


def main():
    if len(sys.argv) >= 2:
        file_name = sys.argv[1]
    else:
        file_name = None

    if file_name is None:
        # ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã‚·ã‚§ãƒ«
        signal.signal(signal.SIGINT, sigint_handler)

        while True:
            # è‰²ä»˜ã‘
            yello_start = "\033[33m"
            end_of_color = "\033[0m"
            line = input(f"ğŸğŸš {yello_start}pyminish> {end_of_color} >")
            interpret_line(line)

    else:
        # ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
        with open(file_name) as f:
            # ã‚·ã‚§ãƒ«ã®å„è¡Œã‚’å®Ÿè¡Œ
            for line in f:
                interpret_line(line)


if __name__ == "__main__":
    main()
